From 7540a5d1afe1de64d6bd8997ab9cdad1b50e7c6a Mon Sep 17 00:00:00 2001
From: Etienne <etmartin@etmartin-desktop.(none)>
Date: Thu, 2 Aug 2012 10:41:48 -0400
Subject: [PATCH 10/14] vdev core build clean up / core vdev + msix_virtual device split

---
 CONFIGS/x86_64_kvm_host_defconfig |    8 +-
 drivers/Kconfig                   |    2 +
 drivers/Makefile                  |    2 +-
 drivers/vdev/Kconfig              |   12 +
 drivers/vdev/Makefile             |    4 +-
 drivers/vdev/core.c               |  624 ----------------------------------
 drivers/vdev/msix_vdevice.c       |  668 +++++++++++++++++++++++++++++++++++++
 drivers/vdev/vdev.c               |  624 ++++++++++++++++++++++++++++++++++
 include/linux/vdevice.h           |   65 ++++
 9 files changed, 1379 insertions(+), 630 deletions(-)
 create mode 100644 drivers/vdev/Kconfig
 delete mode 100644 drivers/vdev/core.c
 create mode 100644 drivers/vdev/msix_vdevice.c
 create mode 100644 drivers/vdev/vdev.c
 create mode 100644 include/linux/vdevice.h

diff --git a/CONFIGS/x86_64_kvm_host_defconfig b/CONFIGS/x86_64_kvm_host_defconfig
index b6cfebe..0bcecb8 100644
--- a/CONFIGS/x86_64_kvm_host_defconfig
+++ b/CONFIGS/x86_64_kvm_host_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.32
-# Wed May 16 19:01:38 2012
+# Thu Aug  2 14:31:17 2012
 #
 CONFIG_64BIT=y
 # CONFIG_X86_32 is not set
@@ -945,7 +945,6 @@ CONFIG_MISC_DEVICES=y
 # CONFIG_SGI_GRU is not set
 # CONFIG_ISL29003 is not set
 # CONFIG_VMWARE_BALLOON is not set
-CONFIG_VIRTUAL_DEVICE=m
 # CONFIG_C2PORT is not set
 
 #
@@ -2459,6 +2458,8 @@ CONFIG_X86_PLATFORM_DEVICES=y
 # CONFIG_TOPSTAR_LAPTOP is not set
 # CONFIG_ACPI_TOSHIBA is not set
 # CONFIG_INTEL_IPS is not set
+CONFIG_VDEV=y
+CONFIG_VDEV_MSIX=m
 
 #
 # Firmware Drivers
@@ -2789,7 +2790,8 @@ CONFIG_DYNAMIC_FTRACE=y
 CONFIG_FUNCTION_PROFILER=y
 CONFIG_FTRACE_MCOUNT_RECORD=y
 # CONFIG_FTRACE_STARTUP_TEST is not set
-# CONFIG_MMIOTRACE is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
 CONFIG_RING_BUFFER_BENCHMARK=m
 CONFIG_PROVIDE_OHCI1394_DMA_INIT=y
 # CONFIG_BUILD_DOCSRC is not set
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 48bbdbe..8b1dd9b 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -113,4 +113,6 @@ source "drivers/xen/Kconfig"
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
+source "drivers/vdev/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index c12015a..e361944 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -113,5 +113,5 @@ obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
 #obj-m				+= panini/
-obj-y				+= vdev/
+obj-$(CONFIG_VDEV)		+= vdev/
 
diff --git a/drivers/vdev/Kconfig b/drivers/vdev/Kconfig
new file mode 100644
index 0000000..9f76456
--- /dev/null
+++ b/drivers/vdev/Kconfig
@@ -0,0 +1,12 @@
+menuconfig VDEV
+	bool "VDEV emulation backend"
+	depends on PCI
+
+if VDEV
+
+config VDEV_MSIX
+	tristate "MSIX virtual device emulation"
+	help
+	  TODO
+
+endif
diff --git a/drivers/vdev/Makefile b/drivers/vdev/Makefile
index afc335c..318213d 100644
--- a/drivers/vdev/Makefile
+++ b/drivers/vdev/Makefile
@@ -1,2 +1,2 @@
-obj-y += vdev.o
-vdev-y := core.o
+obj-$(CONFIG_VDEV)	+= vdev.o
+obj-$(CONFIG_VDEV_MSIX)	+= msix_vdevice.o
diff --git a/drivers/vdev/core.c b/drivers/vdev/core.c
deleted file mode 100644
index 374949c..0000000
--- a/drivers/vdev/core.c
+++ /dev/null
@@ -1,624 +0,0 @@
-#include <linux/module.h>
-#include <linux/mmiotrace.h>
-#include <linux/debugfs.h>
-#include <linux/uaccess.h>
-#include <linux/io.h>
-#include <linux/version.h>
-#include <linux/kallsyms.h>
-#include <linux/vdev.h>
-#include <linux/percpu.h>
-#include <linux/cpu.h>
-#include <asm/pgtable.h>
-#include <asm/e820.h> /* for ISA_START_ADDRESS */
-#include <asm/atomic.h>
-
-#include "../../arch/x86/mm/pf_in.h"
-
-#define NAME "vdev_emul: "
-
-struct trap_reason {
-	unsigned long addr;
-	unsigned long ip;
-	enum reason_type type;
-	int active_traces;
-};
-
-struct remap_trace {
-	struct list_head list;
-	struct kmmio_probe probe;
-	resource_size_t phys;
-	unsigned long id;
-};
-
-static DEFINE_SPINLOCK(vdev_lock);
-static LIST_HEAD(vdev_list);
-
-/* Accessed per-cpu. */
-static DEFINE_PER_CPU(struct trap_reason, vdev_pf_reason);
-static DEFINE_PER_CPU(struct mmiotrace_rw, vdev_cpu_trace);
-
-static DEFINE_SPINLOCK(trace_lock);
-static atomic_t mmiotrace_enabled = ATOMIC_INIT(0);
-static LIST_HEAD(trace_list);		/* struct remap_trace */
-
-static bool is_enabled(void)
-{
-	return atomic_read(&mmiotrace_enabled);
-}
-
-static void print_pte(unsigned long address)
-{
-	unsigned int level;
-	pte_t *pte = lookup_address(address, &level);
-
-	if (!pte) {
-		pr_err(NAME "Error in %s: no pte for page 0x%08lx\n",
-							__func__, address);
-		return;
-	}
-
-	if (level == PG_LEVEL_2M) {
-		pr_emerg(NAME "4MB pages are not currently supported: "
-							"0x%08lx\n", address);
-		BUG();
-	}
-	pr_info(NAME "pte for 0x%lx: 0x%llx 0x%llx\n", address,
-		(unsigned long long)pte_val(*pte),
-		(unsigned long long)pte_val(*pte) & _PAGE_PRESENT);
-}
-
-/*
- * For some reason the pre/post pairs have been called in an
- * unmatched order. Report and die.
- */
-static void die_kmmio_nesting_error(struct pt_regs *regs, unsigned long addr)
-{
-	const struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
-	pr_emerg(NAME "unexpected fault for address: 0x%08lx, "
-					"last fault for address: 0x%08lx\n",
-					addr, my_reason->addr);
-	print_pte(addr);
-	print_symbol(KERN_EMERG "faulting IP is at %s\n", regs->ip);
-	print_symbol(KERN_EMERG "last faulting IP was at %s\n", my_reason->ip);
-#ifdef __i386__
-	pr_emerg("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
-			regs->ax, regs->bx, regs->cx, regs->dx);
-	pr_emerg("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
-			regs->si, regs->di, regs->bp, regs->sp);
-#else
-	pr_emerg("rax: %016lx   rcx: %016lx   rdx: %016lx\n",
-					regs->ax, regs->cx, regs->dx);
-	pr_emerg("rsi: %016lx   rdi: %016lx   rbp: %016lx   rsp: %016lx\n",
-				regs->si, regs->di, regs->bp, regs->sp);
-#endif
-	put_cpu_var(vdev_pf_reason);
-	BUG();
-}
-
-static void pre(struct kmmio_probe *p, struct pt_regs *regs,
-						unsigned long addr)
-{
-	struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
-	struct mmiotrace_rw *my_trace = &get_cpu_var(vdev_cpu_trace);
-	const unsigned long instptr = instruction_pointer(regs);
-	const enum reason_type type = get_ins_type(instptr);
-	struct remap_trace *trace = p->private;
-
-	/* it doesn't make sense to have more than one active trace per cpu */
-	if (my_reason->active_traces)
-		die_kmmio_nesting_error(regs, addr);
-	else
-		my_reason->active_traces++;
-
-	my_reason->type = type;
-	my_reason->addr = addr;
-	my_reason->ip = instptr;
-
-	my_trace->phys = addr - trace->probe.addr + trace->phys;
-	my_trace->map_id = trace->id;
-
-	my_trace->pc = instptr;
-
-	/*
-	 * XXX: the timestamp recorded will be *after* the tracing has been
-	 * done, not at the time we hit the instruction. SMP implications
-	 * on event ordering?
-	 */
-
-	switch (type) {
-	case REG_READ:
-		my_trace->opcode = MMIO_READ;
-		my_trace->width = get_ins_mem_width(instptr);
-		break;
-	case REG_WRITE:
-		my_trace->opcode = MMIO_WRITE;
-		my_trace->width = get_ins_mem_width(instptr);
-		my_trace->value = get_ins_reg_val(instptr, regs);
-		break;
-	case IMM_WRITE:
-		my_trace->opcode = MMIO_WRITE;
-		my_trace->width = get_ins_mem_width(instptr);
-		my_trace->value = get_ins_imm_val(instptr);
-		break;
-	default:
-		{
-			unsigned char *ip = (unsigned char *)instptr;
-			my_trace->opcode = MMIO_UNKNOWN_OP;
-			my_trace->width = 0;
-			my_trace->value = (*ip) << 16 | *(ip + 1) << 8 |
-								*(ip + 2);
-		}
-	}
-	put_cpu_var(vdev_cpu_trace);
-	put_cpu_var(vdev_pf_reason);
-}
-
-static void post(struct kmmio_probe *p, unsigned long condition,
-							struct pt_regs *regs)
-{
-	int rc;
-	unsigned long val;
-	struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
-	struct mmiotrace_rw *my_trace = &get_cpu_var(vdev_cpu_trace);
-
-	/* this should always return the active_trace count to 0 */
-	my_reason->active_traces--;
-	if (my_reason->active_traces) {
-		pr_emerg(NAME "unexpected post handler");
-		BUG();
-	}
-
-	/* 
-	 * Here vdev_dispatch_io looks if the current address belongs
-	 * to the emulation layer; If it does it returns 0
-	 */
-	val = 0;
-	rc = vdev_dispatch_io(my_trace,&val);
-
-	switch (my_reason->type) {
-	case REG_READ:
-		/* 
-		 * set_ins_reg_val walk the instruction sets and identify the register
-		 * that contain the readed value. For the emulation case we replace that
-		 * value with the emulated one returned from vdev_dispatch_io.
-		 * 	show_registers(regs);
-		 * 	The trace decoding is performed after to maintain consistency
-		 */
-		if(rc==0)
-			set_ins_reg_val(my_reason->ip, regs, val);
-
-/* not needed
-		my_trace->value = get_ins_reg_val(my_reason->ip, regs);*/
-		break;
-	default:
-		break;
-	}
-
-	/* Here we callback into vdev with mytrace information */
-	put_cpu_var(vdev_cpu_trace);
-	put_cpu_var(vdev_pf_reason);
-}
-
-static void ioremap_trace_core(resource_size_t offset, unsigned long size,
-							void __iomem *addr)
-{
-	static atomic_t next_id;
-	struct remap_trace *trace = kmalloc(sizeof(*trace), GFP_KERNEL);
-	/* These are page-unaligned. */
-	struct mmiotrace_map map = {
-		.phys = offset,
-		.virt = (unsigned long)addr,
-		.len = size,
-		.opcode = MMIO_PROBE
-	};
-
-	if (!trace) {
-		pr_err(NAME "kmalloc failed in ioremap\n");
-		return;
-	}
-
-	*trace = (struct remap_trace) {
-		.probe = {
-			.addr = (unsigned long)addr,
-			.len = size,
-			.pre_handler = pre,
-			.post_handler = post,
-			.private = trace
-		},
-		.phys = offset,
-		.id = atomic_inc_return(&next_id)
-	};
-	map.map_id = trace->id;
-
-	spin_lock_irq(&trace_lock);
-	if (!is_enabled()) {
-		kfree(trace);
-		goto not_enabled;
-	}
-
-	list_add_tail(&trace->list, &trace_list);
-	register_kmmio_probe(&trace->probe);
-
-not_enabled:
-	spin_unlock_irq(&trace_lock);
-}
-
-static void iounmap_trace_core(volatile void __iomem *addr)
-{
-	struct mmiotrace_map map = {
-		.phys = 0,
-		.virt = (unsigned long)addr,
-		.len = 0,
-		.opcode = MMIO_UNPROBE
-	};
-	struct remap_trace *trace;
-	struct remap_trace *tmp;
-	struct remap_trace *found_trace = NULL;
-
-	pr_debug(NAME "Unmapping %p.\n", addr);
-
-	spin_lock_irq(&trace_lock);
-	if (!is_enabled())
-		goto not_enabled;
-
-	list_for_each_entry_safe(trace, tmp, &trace_list, list) {
-		if ((unsigned long)addr == trace->probe.addr) {
-			unregister_kmmio_probe(&trace->probe);
-			list_del(&trace->list);
-			found_trace = trace;
-			break;
-		}
-	}
-	map.map_id = (found_trace) ? found_trace->id : -1;
-
-not_enabled:
-	spin_unlock_irq(&trace_lock);
-	if (found_trace) {
-		synchronize_rcu(); /* unregister_kmmio_probe() requirement */
-		kfree(found_trace);
-	}
-}
-
-static void clear_trace_list(void)
-{
-	struct remap_trace *trace;
-	struct remap_trace *tmp;
-
-	/*
-	 * No locking required, because the caller ensures we are in a
-	 * critical section via mutex, and is_enabled() is false,
-	 * i.e. nothing can traverse or modify this list.
-	 * Caller also ensures is_enabled() cannot change.
-	 */
-	list_for_each_entry(trace, &trace_list, list) {
-		pr_notice(NAME "purging non-iounmapped "
-					"trace @0x%08lx, size 0x%lx.\n",
-					trace->probe.addr, trace->probe.len);
-		unregister_kmmio_probe(&trace->probe);
-	}
-	synchronize_rcu(); /* unregister_kmmio_probe() requirement */
-
-	list_for_each_entry_safe(trace, tmp, &trace_list, list) {
-		list_del(&trace->list);
-		kfree(trace);
-	}
-}
-
-#ifdef CONFIG_HOTPLUG_CPU
-static cpumask_var_t downed_cpus;
-
-static void enter_uniprocessor(void)
-{
-	int cpu;
-	int err;
-
-	if (downed_cpus == NULL &&
-	    !alloc_cpumask_var(&downed_cpus, GFP_KERNEL)) {
-		pr_notice(NAME "Failed to allocate mask\n");
-		goto out;
-	}
-
-	get_online_cpus();
-	cpumask_copy(downed_cpus, cpu_online_mask);
-	cpumask_clear_cpu(cpumask_first(cpu_online_mask), downed_cpus);
-	if (num_online_cpus() > 1)
-		pr_notice(NAME "Disabling non-boot CPUs...\n");
-	put_online_cpus();
-
-	for_each_cpu(cpu, downed_cpus) {
-		err = cpu_down(cpu);
-		if (!err)
-			pr_info(NAME "CPU%d is down.\n", cpu);
-		else
-			pr_err(NAME "Error taking CPU%d down: %d\n", cpu, err);
-	}
-out:
-	if (num_online_cpus() > 1)
-		pr_warning(NAME "multiple CPUs still online, "
-						"may miss events.\n");
-}
-
-/* __ref because leave_uniprocessor calls cpu_up which is __cpuinit,
-   but this whole function is ifdefed CONFIG_HOTPLUG_CPU */
-static void __ref leave_uniprocessor(void)
-{
-	int cpu;
-	int err;
-
-	if (downed_cpus == NULL || cpumask_weight(downed_cpus) == 0)
-		return;
-	pr_notice(NAME "Re-enabling CPUs...\n");
-	for_each_cpu(cpu, downed_cpus) {
-		err = cpu_up(cpu);
-		if (!err)
-			pr_info(NAME "enabled CPU%d.\n", cpu);
-		else
-			pr_err(NAME "cannot re-enable CPU%d: %d\n", cpu, err);
-	}
-}
-
-#else /* !CONFIG_HOTPLUG_CPU */
-static void enter_uniprocessor(void)
-{
-	if (num_online_cpus() > 1)
-		pr_warning(NAME "multiple CPUs are online, may miss events. "
-			"Suggest booting with maxcpus=1 kernel argument.\n");
-}
-
-static void leave_uniprocessor(void)
-{
-}
-#endif
-
-void vdev_ioremap(resource_size_t offset, unsigned long size,
-	void __iomem *addr)
-{
-	if (!is_enabled()) /* recheck and proper locking in *_core() */
-		return;
-
-	/*
-	 * Here we check FIRST is the offset / size fall into an emulated 
-	 * device region ONLY then we register the emulation back-end
-	 */
-	ioremap_trace_core(offset, size, addr);
-
-	pr_debug("user_mmiotrace_ioremap_*(0x%llx, 0x%lx) = %p\n",
-			(unsigned long long)offset, size, addr);
-}
-
-void vdev_iounmap(volatile void __iomem *addr)
-{
-	if (!is_enabled()) /* recheck and proper locking in *_core() */
-		return;
-	
-	iounmap_trace_core(addr);
-
-	pr_debug("user_mmiotrace_iounmap_%p\n",addr);
-}
-
-void vdev_enable_mmiotrace(void)
-{
-	if (is_enabled())
-		goto out;
-	
-	kmmio_init();
-	enter_uniprocessor();
-	pr_info(NAME "enabled.\n");
-out:
-	atomic_inc(&mmiotrace_enabled);
-}
-
-void vdev_disable_mmiotrace(void)
-{
-	if (atomic_dec_and_test(&mmiotrace_enabled)){
-		BUG_ON(is_enabled());
-		clear_trace_list(); /* guarantees: no more kmmio callbacks */
-		leave_uniprocessor();
-		kmmio_cleanup();
-		pr_info(NAME "disabled.\n");
-	}
-}
-
-
-
-static struct vdev_io *vdev_search(struct mmiotrace_rw *mmio, int *res, resource_size_t *offset)
-{
-	int x;
-	struct vdev_io *io;
-	struct vdev_resource *vdev_resource;
-	resource_size_t start;
-	resource_size_t end;
-
-	spin_lock(&vdev_lock);
-	list_for_each_entry(io, &vdev_list, list){
-		for(x=0;x<PCI_NUM_RESOURCES;x++){
-			vdev_resource = &io->vdev_resource[x];
-			start = vdev_resource->resource.start;
-			end = vdev_resource->resource.end;
-		//	printk("MMIO %lx %lx %lx\n",(unsigned long)mmio->phys, start,end);
-			if ( (mmio->phys >= start) && (mmio->phys <= end) ){
-				spin_unlock(&vdev_lock);
-		//		printk("MMIO found %lx\n",(unsigned long)mmio->phys);
-				*offset = mmio->phys - start;
-				*res = x;
-				return io;
-			}
-		}
-	}
-	spin_unlock(&vdev_lock);
-	return NULL;
-}
-
-/*
- * This is the call back to the emulation back-end;
- * This is either coming from the remap_pfn_rage PTE fault
- * on hostOS OR
- * from KVM vcpu_mmio rd/wr
- * 
- * the vcpu_mmio is driver by the tdp_pagefault() and works
- * only for emulated device registered with cpu_register_io_memory
- * Memory is normally registered with qemu_ram_alloc_from_ptr and doesn't
- * trap on each access.
- *
- * OPTION;
- * For PT vdev device in qemu we set it up as cpu_register_io_memory; We trap
- * in vcpu_mmio and send to the emulation layer. This would utilize the 
- * page_fault/kmmio mechanism like when on the host.
- * Can also be interceted in KVM directly
- *
- * KVM kvm_io_bus_write are matching against guest physical
- * addr because they know where the mapping is going to be located
- * in guest physical ADDR; equivalent would be to map 
- * mmap ( hint = my base addr; )...
- *
- * KVM iobus require the kvm context!
- *
- * !!!
- * With qemu we can configure the io for slow_map i.e. trap in qemu and qemu
- * does the access; This is EXACTLY what we need here and there is only
- * one entry point into the emulation backend
- */
-int vdev_dispatch_io(struct mmiotrace_rw *mmio, unsigned long *val)
-{
-	int res;
-	unsigned long value;
-	resource_size_t offset;
-	struct vdev_io *io;
-
-	io = vdev_search(mmio, &res, &offset);
-	if(!io)
-		return -1;
-
-	if(mmio->opcode == MMIO_READ){
-		switch(mmio->width){
-			case 1:
-				if(io->readb){
-					value = io->readb(&io->vdev_resource[res],offset);
-					*val = value;
-					return 0;
-				}
-				return -1;
-			case 2:
-				if(io->readw){
-					value = io->readw(&io->vdev_resource[res],offset);
-					*val = value;
-					return 0;
-				}
-				return -1;
-			case 4:
-				if(io->readl){
-					value = io->readl(&io->vdev_resource[res],offset);
-					*val = value;
-					return 0;
-				}
-				return -1;
-			case 8:
-				if(io->readd){
-					value = io->readd(&io->vdev_resource[res],offset);
-					*val = value;
-					return 0;
-				}
-				return -1;
-			default:
-				printk("Invalid io size %d\n",mmio->width);
-				return -1;
-		}
-	}
-
-	if(mmio->opcode == MMIO_WRITE){
-		switch(mmio->width){
-			case 1:
-				if(io->writeb){
-					io->writeb(&io->vdev_resource[res],offset, mmio->value);
-					return 0;
-				}
-				return -1;
-			case 2:
-				if(io->writew){
-					io->writew(&io->vdev_resource[res],offset, mmio->value);
-					return 0;
-				}
-				return -1;
-			case 4:
-				if(io->writel){
-					io->writel(&io->vdev_resource[res],offset, mmio->value);
-					return 0;
-				}
-				return -1;
-			case 8:
-				if(io->writed){
-					io->writed(&io->vdev_resource[res],offset, mmio->value);
-					return 0;
-				}
-				return -1;
-			default:
-				printk("Invalid io size %d\n",mmio->width);
-				return -1;
-		}
-	}
-
-	return -1;
-}
-EXPORT_SYMBOL(vdev_dispatch_io);
-
-/*
- * Virtual device / SW SRIOV register themself here
- */
-int vdev_register_device(struct vdev_io *vdev)
-{
-	spin_lock(&vdev_lock);
-	list_add(&vdev->list, &vdev_list);
-	//TODO check if it already exist and so on...
-	spin_unlock(&vdev_lock);
-	vdev_enable_mmiotrace();
-	return 0;
-}
-EXPORT_SYMBOL(vdev_register_device);
-
-/*
- * Virtual device / SW SRIOV un-register themself here
- */
-int vdev_unregister_device(struct vdev_io *vdev)
-{
-	int found=0;
-	struct vdev_io *p;
-
-	spin_lock(&vdev_lock);
-	list_for_each_entry(p, &vdev_list, list){
-		if(vdev == p){
-			list_del(&p->list);
-			found=1;
-			break;
-		}
-	}
-	spin_unlock(&vdev_lock);
-	if(found)
-		vdev_disable_mmiotrace();
-		
-	return 0;
-}
-EXPORT_SYMBOL(vdev_unregister_device);
-
-/*
- * Here we arm the remap_pfn_range KMMIO tracing subsystem only if it deal 
- * with a fully registered virtual device.
- *
- * This path is also called from the mmiotrace_ioremap / kernel ioremap path
- *
- */
-void vdev_register_mapping(resource_size_t offset, unsigned long size,
-	void __iomem *addr)
-{
-	vdev_ioremap(offset, size, addr);
-}
-EXPORT_SYMBOL(vdev_register_mapping);
-
-void vdev_unregister_mapping(volatile void __iomem *addr)
-{
-	vdev_iounmap(addr);
-}
-EXPORT_SYMBOL(vdev_unregister_mapping);
-
-
-
-
diff --git a/drivers/vdev/msix_vdevice.c b/drivers/vdev/msix_vdevice.c
new file mode 100644
index 0000000..43071df
--- /dev/null
+++ b/drivers/vdev/msix_vdevice.c
@@ -0,0 +1,668 @@
+/*
+ * vdevice - Virtual Device Framework
+ *
+ * Copyright (C) 2010 Cisco Systems
+ * Author: Etienne Martineau <etmartin@cisco.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.
+ * Copyright (C) 2010 Cisco Systems
+ *
+ */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/mutex.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/bigphysarea.h>
+#include <linux/platform_device.h>
+#include <linux/vdevice.h>
+#include <linux/vdev.h>
+
+#define DRIVER_VERSION	"0.01"
+#define DRIVER_AUTHOR	"Etienne Martineau <etmartin@cisco.com>"
+#define DRIVER_DESC	"Virtual Device Framework"
+
+#define DPRINTK(fmt, args...)	\
+	do{	\
+		if(debug) \
+			printk(KERN_DEBUG "%s: " fmt, __func__ , ## args); \
+} while (0)
+
+#define MIN(a,b)        (min(a,b))
+#define MAX(a,b)        (max(a,b))
+
+static int debug=0;
+MODULE_PARM_DESC(debug, "");
+module_param(debug, bool, 0644);
+
+static LIST_HEAD(vfcn_list);
+static DEFINE_SPINLOCK(vfcn_list_lock);
+static DEFINE_MUTEX(mutex);
+static struct pci_ops local_pci_root_ops;
+static struct pci_dev *Gpdev;
+
+static void vdevice_add(struct vdev *dev)
+{
+	spin_lock(&vfcn_list_lock);	
+	list_add(&dev->list,&vfcn_list);
+	spin_unlock(&vfcn_list_lock);
+}
+
+static void vdevice_del(struct vdev *dev)
+{
+	spin_lock(&vfcn_list_lock);	
+	list_del(&dev->list);
+	spin_unlock(&vfcn_list_lock);
+}
+
+static struct vdev * vdevice_find(unsigned int seg, unsigned int bus,
+			  unsigned int devfn)
+{
+	struct list_head *pos;
+	struct vdev *ptr;
+	
+	spin_lock(&vfcn_list_lock);	
+	list_for_each(pos, &vfcn_list){
+		ptr= list_entry(pos, struct vdev, list);
+		if(seg == ptr->aseg && bus==ptr->abus && (devfn == ptr->adevfn)){
+			spin_unlock(&vfcn_list_lock);
+			DPRINTK("vdevice_find %x %x:%x.%x",seg,bus,PCI_SLOT(devfn),PCI_FUNC(devfn));
+			return ptr;
+		}
+	}
+	spin_unlock(&vfcn_list_lock);
+	return NULL;
+}
+
+static int vfcn_read(struct vdev *pci_dev, int reg, int len, u32 *val)
+{
+	u32 value = 0;
+
+	len = MIN(len, (int)(MAX_CFG_SIZE - reg));
+	memcpy(&value, (unsigned char*)(pci_dev->config) + reg, len);
+	*val = le32_to_cpu(value);
+	DPRINTK("CFG Read %x->%d= %x\n",reg,len,*val);
+	return 0;
+}
+
+static int vfcn_write(struct vdev *pci_dev, int reg, int len, u32 val)
+{
+	int i;
+
+	DPRINTK("CFG Write %x->%d= %x\n",reg,len,val);
+	if(len==4 && ((val &0xffffffff) ==0xfffffffe)){ /* Weird config */
+		val=0;
+		DPRINTK("BAR %x -> %x\n",reg,val);
+	}
+	else if(len==4 && ((val &0xfffffff0) ==0xfffffff0)){ /* probing for SIZE */
+		val = pci_dev->bar[(reg>>2)-1];
+		DPRINTK("BAR %x -> %x\n",reg,val);
+	}
+	for (i = 0; i < len; i++) {
+		*((unsigned char*)(pci_dev->config) + reg + i) = val & 0xff;
+		val >>= 8;
+	}
+	return 0;
+}
+
+/* 
+ * pci_read / pci_write are based on B:D.F and so there
+ * is no direct handle mapping to it's pci_dev structure.
+ * For that reason we used a global lookup list to get to pci_dev
+ */
+static int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)
+{
+	struct vdev *dev;
+	dev = vdevice_find(pci_domain_nr(bus), bus->number, devfn);
+	if(!dev)
+		return local_pci_root_ops.read(bus, devfn, where, size, value);
+	return vfcn_read(dev,where,size,value);
+}
+
+static int pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 value)
+{
+	struct vdev *dev;
+	dev = vdevice_find(pci_domain_nr(bus), bus->number, devfn);
+	if(!dev)
+		return local_pci_root_ops.write(bus,devfn, where, size, value);
+	return vfcn_write(dev,where,size,value);
+}
+
+u8 vdev_readb(struct vdev_resource *vdev_resource, resource_size_t offset)
+{
+	u8 val;
+	volatile u8 *ptr = (volatile u8*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	val = *ptr;
+	DPRINTK("readb phys %lx = %x \n",(unsigned long) (resource->start + offset), val);
+	return val;
+}
+u16 vdev_readw(struct vdev_resource *vdev_resource, resource_size_t offset)
+{
+	u16 val;
+	volatile u16 *ptr = (volatile u16*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	val = *ptr;
+	DPRINTK("readw phys %lx = %x \n",(unsigned long) (resource->start + offset), val);
+	return val;
+}
+u32 vdev_readl(struct vdev_resource *vdev_resource, resource_size_t offset)
+{
+	u32 val;
+	volatile u32 *ptr = (volatile u32*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	val = *ptr;
+	DPRINTK("readl phys %lx = %x \n",(unsigned long) (resource->start + offset), val);
+	return val;
+}
+u64 vdev_readd(struct vdev_resource *vdev_resource, resource_size_t offset)
+{
+	u64 val;
+	volatile u64 *ptr = (volatile u64*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	val = *ptr;
+	DPRINTK("readd phys %lx = %lx \n",(unsigned long) (resource->start + offset), val);
+	return val;
+}
+
+int vdev_writeb(struct vdev_resource *vdev_resource, resource_size_t offset, u8 val)
+{
+	volatile u8 *ptr = (volatile u8*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	*ptr = val;
+	DPRINTK("writeb phys %lx val %x\n",(unsigned long)(resource->start + offset), val);
+	return 0;
+}
+int vdev_writew(struct vdev_resource *vdev_resource, resource_size_t offset, u16 val)
+{
+	volatile u16 *ptr = (volatile u16*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	*ptr = val;
+	DPRINTK("writew phys %lx val %x\n",(unsigned long)(resource->start + offset), val);
+	return 0;
+}
+int vdev_writel(struct vdev_resource *vdev_resource, resource_size_t offset, u32 val)
+{
+	int x;
+	volatile u32 *ptr = (volatile u32*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	*ptr = val;
+	DPRINTK("writel phys %lx val %x\n",(unsigned long)(resource->start + offset), val);
+
+#if 0
+/* There is a problem when runnint virtual device with kmmio emulation
+ * in a VM for the MSI; register are truncated somehow...*/
+	if(offset == 0x98){
+		printk("DUMP\n");
+		ptr = (volatile u32*)vdev_resource->opaque;
+		for(x=0;x<=0x98;x+=4){
+			printk("%x -> %lx\n",x,ptr[x]);
+		}
+	}
+#endif
+	return 0;
+}
+
+int vdev_writed(struct vdev_resource *vdev_resource, resource_size_t offset, u64 val)
+{
+	volatile u64 *ptr = (volatile u64*)vdev_resource->opaque + offset;
+	struct resource *resource=&vdev_resource->resource;
+
+	*ptr = val;
+	DPRINTK("writed phys %lx val %x\n",(unsigned long)(resource->start + offset), val);
+	return 0;
+}
+
+void test_io(struct pci_dev *dev)
+{
+	int nr,x;
+	void *bar0, *bar2;
+	unsigned char *bbar0,*bbar2;
+	unsigned short *wbar0,*wbar2;
+	unsigned int *lbar0,*lbar2;
+	unsigned long *dbar0,*dbar2;
+
+	bar0=pci_iomap(dev, 0, 0);
+	if(!bar0){
+		DPRINTK("Cannot mmap BAR0\n");
+		return;
+	}
+
+	bar2=pci_iomap(dev, 2, 0);
+	if(!bar2){
+		DPRINTK("Cannot mmap BAR2\n");
+		return;
+	}
+	
+	bbar0=bar0;
+	wbar0=bar0;
+	lbar0=bar0;
+	dbar0=bar0;
+
+	bbar2=bar2;
+	wbar2=bar2;
+	lbar2=bar2;
+	dbar2=bar2;
+
+	nr = 5;
+
+	DPRINTK("\nBAR2 write bytes");
+	for(x=0;x<nr;x++){
+		bbar2[x] = x;
+	}
+	DPRINTK("\nBAR2 read bytes");
+	for(x=0;x<nr;x++){
+		DPRINTK("_%x_",bbar2[x]);
+	}
+
+	DPRINTK("\nBAR2 write short");
+	for(x=0;x<nr;x++){
+		wbar2[x] = x;
+	}
+	DPRINTK("\nBAR2 read short");
+	for(x=0;x<nr;x++){
+		DPRINTK("_%x_",wbar2[x]);
+	}
+
+	DPRINTK("\nBAR2 write long");
+	for(x=0;x<nr;x++){
+		lbar2[x] = x;
+	}
+	DPRINTK("\nBAR2 read long");
+	for(x=0;x<nr;x++){
+		DPRINTK("_%x_",lbar2[x]);
+	}
+
+	DPRINTK("\nBAR2 write double");
+	for(x=0;x<nr;x++){
+		dbar2[x] = x;
+	}
+	DPRINTK("\nBAR2 read double");
+	for(x=0;x<nr;x++){
+		DPRINTK("_%x_",dbar2[x]);
+	}
+}
+
+static struct vdev_io *vdev_register(struct pci_dev *dev)
+{
+	int x, len;
+	struct vdev_io *io;
+
+	io = kzalloc(sizeof(struct vdev_io), GFP_KERNEL);
+	if(!io)
+		BUG();
+
+	io->readb=vdev_readb;
+	io->readw=vdev_readw;
+	io->readl=vdev_readl;
+	io->readd=vdev_readd;
+	io->writeb=vdev_writeb;
+	io->writew=vdev_writew;
+	io->writel=vdev_writel;
+	io->writed=vdev_writed;
+
+	for(x=0;x<PCI_NUM_RESOURCES;x++){
+		if(dev->resource[x].start){
+			len = dev->resource[x].end - dev->resource[x].start;
+			io->vdev_resource[x].opaque = kzalloc(len, GFP_KERNEL);
+			if(!io->vdev_resource[x].opaque)
+				BUG();
+			io->vdev_resource[x].resource.start = dev->resource[x].start;
+			io->vdev_resource[x].resource.end = dev->resource[x].end;
+			DPRINTK("Resource %d size %x; %lx %lx\n",x,len, io->vdev_resource[x].resource.start,
+					io->vdev_resource[x].resource.end);
+		}
+	}
+	/* 
+	 * There is 2 BAR in here BAR0 and BAR2
+	 * BAR2 expose the MSI-X vector and from the VM we want
+	 * BAR0 to aliase BAR2
+	 */
+	kfree(io->vdev_resource[0].opaque);
+	io->vdev_resource[0].opaque = io->vdev_resource[2].opaque;
+
+	vdev_register_device(io);
+	DPRINTK("vdev_register_io OK\n");
+
+	if(debug)
+		test_io(dev);
+
+	return io;
+}
+
+static void vdev_unregister(struct vdev *dev)
+{
+//TODO kfree of resource
+	vdev_unregister_device(dev->vdev_io);
+	kfree(dev->vdev_io);
+}
+
+static int vdev_insert(struct vdev *dev, struct pci_dev *pdev)
+{
+	if(dev->type == NEW_FUNCTION){
+		dev->abus=pdev->bus->number;
+		dev->adevfn=PCI_DEVFN(PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn+dev->fcnnr));
+
+		DPRINTK("Inserting %x:%x.%x under %x:%x.%x",dev->abus,PCI_SLOT(dev->adevfn),
+			PCI_FUNC(dev->adevfn), pdev->bus->number,PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+
+		/* pdev is now multi function */
+		pdev->multifunction = 1;
+
+	}
+	else if(dev->type == NEW_DEVICE){
+		/* In this case this pdev must be a downstream port */
+		if(pdev->subordinate && pdev->subordinate->number){
+			dev->abus=pdev->subordinate->number;
+			dev->adevfn=dev->devfn;
+			DPRINTK("Inserting %x:%x.%x under %x:%x.%x",dev->abus,PCI_SLOT(dev->adevfn),
+				PCI_FUNC(dev->adevfn), pdev->bus->number,PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+		}
+		else{
+			DPRINTK("No sub bus #\n");
+			dev->abus=0;
+			dev->adevfn=dev->devfn;
+			DPRINTK("Inserting %x:%x.%x under %x:%x.%x",dev->abus,PCI_SLOT(dev->adevfn),
+				PCI_FUNC(dev->adevfn), pdev->bus->number,PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+		}
+	}
+	else
+		return -EINVAL;
+
+	if(pci_get_bus_and_slot(dev->abus,dev->adevfn))
+		return -EEXIST;
+
+	dev->pdev = pdev;
+
+	/* Get on the global list */
+	vdevice_add(dev);
+
+	pci_rescan_bus(pdev->bus);
+
+	/* Find the vdevice */
+	dev->vdev = pci_get_bus_and_slot(dev->abus,dev->adevfn);
+	if (!dev->vdev){
+		vdevice_del(dev);
+		dev->pdev=NULL;
+		return -EIO;
+	}
+	
+	DPRINTK("Found Virtual device on PCI \n");
+
+	dev->vdev_io = vdev_register(dev->vdev);
+	return 0;
+}
+
+static void vdevice_remove(struct vdev *dev)
+{
+	if(!dev->pdev){
+		DPRINTK("No device to remove");
+		return;
+	}
+
+	DPRINTK("Removing %x:%x.%x from %x:%x.%x",dev->abus,PCI_SLOT(dev->adevfn),
+		PCI_FUNC(dev->adevfn), dev->pdev->bus->number,PCI_SLOT(dev->pdev->devfn), PCI_FUNC(dev->pdev->devfn));
+
+	/* Remove from the global list */
+	vdevice_del(dev);
+	
+	vdev_unregister(dev);
+
+	DPRINTK("pci_remove_bus_device");
+	pci_remove_bus_device(dev->vdev);
+
+	DPRINTK("pci_rescan_bus");
+	pci_rescan_bus(dev->pdev->bus);
+}
+
+/*
+ * Userspace forge the config space and pass it down here.
+ */
+static ssize_t write(struct file * filep, const char __user * buf, 
+			 size_t count, loff_t *ppos)
+{
+	struct vdev *dev = filep->private_data;
+	struct pci_dev *pdev;
+	unsigned long p = *ppos;
+	ssize_t written, sz;
+	unsigned long copied;
+	void *ptr;
+	int size = (sizeof(struct vdev)-USER_OFFSET);
+
+	if(*ppos+count > size)
+		return -EFAULT;
+
+	written = 0;
+
+	while (count > 0) {
+		/*
+		 * Handle first page in case it's not aligned
+		 */
+		if (-p & (PAGE_SIZE - 1))
+			sz = -p & (PAGE_SIZE - 1);
+		else
+			sz = PAGE_SIZE;
+
+		sz = min_t(unsigned long, sz, count);
+
+		ptr = &((unsigned char *)&(dev->type))[p];
+
+		copied = copy_from_user(ptr, buf, sz);
+		if (copied) {
+			written += sz - copied;
+			if (written)
+				break;
+			return -EFAULT;
+		}
+
+		buf += sz;
+		p += sz;
+		count -= sz;
+		written += sz;
+	}
+
+	*ppos += written; //Seek the file
+
+	if((*ppos) == size){ /* transfert is over */
+#if 0
+		{
+			int x;
+			for(x=0;x<256;x++){
+				if(!(x%16))
+					DPRINTK("\n%4o: ",x/2);
+				DPRINTK("%2x ",(unsigned char)dev->config[x]);
+			}
+		}
+#endif
+		/* Find the target device / downstream port */
+		pdev = pci_get_bus_and_slot(dev->B,PCI_DEVFN(dev->D,dev->F));
+		if (!pdev){
+			DPRINTK("Cannot find %x:%x.%x ",dev->B,dev->D,dev->F);
+			return -EINVAL;
+		}
+		DPRINTK("Found %x:%x.%x ",dev->B,dev->D,dev->F);
+
+		/* Put it live */
+		if(vdev_insert(dev, pdev)){
+			DPRINTK("Cannot insert  %x:%x.%x ",dev->B,dev->D,dev->F);
+			return -EINVAL;
+		}
+	}
+	return written;
+}
+
+static ssize_t read(struct file *filep, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	struct vdev *dev = filep->private_data;
+	unsigned long p = *ppos;
+	ssize_t read, sz;
+	char *ptr;
+
+	if(*ppos+count > MAX_CFG_SIZE)
+		return -EFAULT;
+
+	read = 0;
+
+	while (count > 0) {
+		/*
+		 * Handle first page in case it's not aligned
+		 */
+		if (-p & (PAGE_SIZE - 1))
+			sz = -p & (PAGE_SIZE - 1);
+		else
+			sz = PAGE_SIZE;
+
+		sz = min_t(unsigned long, sz, count);
+
+		ptr = &dev->config[p];
+
+		if (copy_to_user(buf, ptr, sz)) {
+			return -EFAULT;
+		}
+
+		buf += sz;
+		p += sz;
+		count -= sz;
+		read += sz;
+	}
+
+	*ppos += read; //Seek the file
+	return read;
+}
+
+static long ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	return -EINVAL;
+}
+
+static long unlocked_ioctl(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	int ret;
+	mutex_lock(&mutex);
+	ret = ioctl(file, cmd, arg);
+	mutex_unlock(&mutex);
+	return ret;
+}
+
+static int open(struct inode *inode, struct file *filep)
+{
+	struct vdev *dev;
+
+	dev=kzalloc(sizeof(struct vdev) ,GFP_KERNEL);
+	if(!dev)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&dev->list);
+
+	filep->private_data = dev;
+	return 0;
+}
+
+static int release(struct inode *inode, struct file *filep)
+{
+	struct vdev *dev = filep->private_data;
+
+	if(!dev)
+		BUG();
+	vdevice_remove(dev);
+	kfree(dev);
+	return 0;
+}
+
+static const struct file_operations fops = {
+	.owner		= THIS_MODULE,
+	.read		= read,
+	.write		= write,
+	.compat_ioctl	= ioctl,
+	.unlocked_ioctl	= unlocked_ioctl,
+	.open		= open,
+	.release	= release,
+};
+
+static struct miscdevice dev =
+{
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "vdev",
+	.fops		= &fops,
+};
+
+static int latch_to_pci_bus(void)
+{
+	/*
+	 * The first thing we do is to override the rd/wr pci_cfg ops
+	 */
+	Gpdev = pci_get_bus_and_slot(0,0);
+	if (!Gpdev)
+		return -1;
+
+	pci_block_user_cfg_access(Gpdev);
+
+	/* Fallback value */
+	local_pci_root_ops.read = Gpdev->bus->ops->read;
+	local_pci_root_ops.write = Gpdev->bus->ops->write;
+
+	/* Redirect ops to our own  HERE we redirect the whole BUS rd/wr...*/
+	Gpdev->bus->ops->read = pci_read;
+	Gpdev->bus->ops->write = pci_write;
+
+	pci_unblock_user_cfg_access(Gpdev);
+
+	return 0;
+}
+
+static void unlatch_from_pci_bus(void)
+{
+	pci_block_user_cfg_access(Gpdev);
+
+	/* Restore ops */
+	Gpdev->bus->ops->read = local_pci_root_ops.read;
+	Gpdev->bus->ops->write = local_pci_root_ops.write;
+
+	pci_unblock_user_cfg_access(Gpdev);
+
+	Gpdev = NULL;
+}
+
+static int __init init(void)
+{
+	int retval;
+
+	if(latch_to_pci_bus()<0)
+		return -EINVAL;
+	
+	retval = misc_register(&dev);
+	if (retval < 0){
+		unlatch_from_pci_bus();
+		return retval;
+	}
+
+	pr_info(DRIVER_DESC " version: " DRIVER_VERSION);
+
+	return 0;
+}
+
+static void __exit cleanup(void)
+{
+	unlatch_from_pci_bus();
+	misc_deregister(&dev);
+}
+
+module_init(init);
+module_exit(cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_AUTHOR(DRIVER_AUTHOR);
diff --git a/drivers/vdev/vdev.c b/drivers/vdev/vdev.c
new file mode 100644
index 0000000..374949c
--- /dev/null
+++ b/drivers/vdev/vdev.c
@@ -0,0 +1,624 @@
+#include <linux/module.h>
+#include <linux/mmiotrace.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/version.h>
+#include <linux/kallsyms.h>
+#include <linux/vdev.h>
+#include <linux/percpu.h>
+#include <linux/cpu.h>
+#include <asm/pgtable.h>
+#include <asm/e820.h> /* for ISA_START_ADDRESS */
+#include <asm/atomic.h>
+
+#include "../../arch/x86/mm/pf_in.h"
+
+#define NAME "vdev_emul: "
+
+struct trap_reason {
+	unsigned long addr;
+	unsigned long ip;
+	enum reason_type type;
+	int active_traces;
+};
+
+struct remap_trace {
+	struct list_head list;
+	struct kmmio_probe probe;
+	resource_size_t phys;
+	unsigned long id;
+};
+
+static DEFINE_SPINLOCK(vdev_lock);
+static LIST_HEAD(vdev_list);
+
+/* Accessed per-cpu. */
+static DEFINE_PER_CPU(struct trap_reason, vdev_pf_reason);
+static DEFINE_PER_CPU(struct mmiotrace_rw, vdev_cpu_trace);
+
+static DEFINE_SPINLOCK(trace_lock);
+static atomic_t mmiotrace_enabled = ATOMIC_INIT(0);
+static LIST_HEAD(trace_list);		/* struct remap_trace */
+
+static bool is_enabled(void)
+{
+	return atomic_read(&mmiotrace_enabled);
+}
+
+static void print_pte(unsigned long address)
+{
+	unsigned int level;
+	pte_t *pte = lookup_address(address, &level);
+
+	if (!pte) {
+		pr_err(NAME "Error in %s: no pte for page 0x%08lx\n",
+							__func__, address);
+		return;
+	}
+
+	if (level == PG_LEVEL_2M) {
+		pr_emerg(NAME "4MB pages are not currently supported: "
+							"0x%08lx\n", address);
+		BUG();
+	}
+	pr_info(NAME "pte for 0x%lx: 0x%llx 0x%llx\n", address,
+		(unsigned long long)pte_val(*pte),
+		(unsigned long long)pte_val(*pte) & _PAGE_PRESENT);
+}
+
+/*
+ * For some reason the pre/post pairs have been called in an
+ * unmatched order. Report and die.
+ */
+static void die_kmmio_nesting_error(struct pt_regs *regs, unsigned long addr)
+{
+	const struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
+	pr_emerg(NAME "unexpected fault for address: 0x%08lx, "
+					"last fault for address: 0x%08lx\n",
+					addr, my_reason->addr);
+	print_pte(addr);
+	print_symbol(KERN_EMERG "faulting IP is at %s\n", regs->ip);
+	print_symbol(KERN_EMERG "last faulting IP was at %s\n", my_reason->ip);
+#ifdef __i386__
+	pr_emerg("eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx\n",
+			regs->ax, regs->bx, regs->cx, regs->dx);
+	pr_emerg("esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx\n",
+			regs->si, regs->di, regs->bp, regs->sp);
+#else
+	pr_emerg("rax: %016lx   rcx: %016lx   rdx: %016lx\n",
+					regs->ax, regs->cx, regs->dx);
+	pr_emerg("rsi: %016lx   rdi: %016lx   rbp: %016lx   rsp: %016lx\n",
+				regs->si, regs->di, regs->bp, regs->sp);
+#endif
+	put_cpu_var(vdev_pf_reason);
+	BUG();
+}
+
+static void pre(struct kmmio_probe *p, struct pt_regs *regs,
+						unsigned long addr)
+{
+	struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
+	struct mmiotrace_rw *my_trace = &get_cpu_var(vdev_cpu_trace);
+	const unsigned long instptr = instruction_pointer(regs);
+	const enum reason_type type = get_ins_type(instptr);
+	struct remap_trace *trace = p->private;
+
+	/* it doesn't make sense to have more than one active trace per cpu */
+	if (my_reason->active_traces)
+		die_kmmio_nesting_error(regs, addr);
+	else
+		my_reason->active_traces++;
+
+	my_reason->type = type;
+	my_reason->addr = addr;
+	my_reason->ip = instptr;
+
+	my_trace->phys = addr - trace->probe.addr + trace->phys;
+	my_trace->map_id = trace->id;
+
+	my_trace->pc = instptr;
+
+	/*
+	 * XXX: the timestamp recorded will be *after* the tracing has been
+	 * done, not at the time we hit the instruction. SMP implications
+	 * on event ordering?
+	 */
+
+	switch (type) {
+	case REG_READ:
+		my_trace->opcode = MMIO_READ;
+		my_trace->width = get_ins_mem_width(instptr);
+		break;
+	case REG_WRITE:
+		my_trace->opcode = MMIO_WRITE;
+		my_trace->width = get_ins_mem_width(instptr);
+		my_trace->value = get_ins_reg_val(instptr, regs);
+		break;
+	case IMM_WRITE:
+		my_trace->opcode = MMIO_WRITE;
+		my_trace->width = get_ins_mem_width(instptr);
+		my_trace->value = get_ins_imm_val(instptr);
+		break;
+	default:
+		{
+			unsigned char *ip = (unsigned char *)instptr;
+			my_trace->opcode = MMIO_UNKNOWN_OP;
+			my_trace->width = 0;
+			my_trace->value = (*ip) << 16 | *(ip + 1) << 8 |
+								*(ip + 2);
+		}
+	}
+	put_cpu_var(vdev_cpu_trace);
+	put_cpu_var(vdev_pf_reason);
+}
+
+static void post(struct kmmio_probe *p, unsigned long condition,
+							struct pt_regs *regs)
+{
+	int rc;
+	unsigned long val;
+	struct trap_reason *my_reason = &get_cpu_var(vdev_pf_reason);
+	struct mmiotrace_rw *my_trace = &get_cpu_var(vdev_cpu_trace);
+
+	/* this should always return the active_trace count to 0 */
+	my_reason->active_traces--;
+	if (my_reason->active_traces) {
+		pr_emerg(NAME "unexpected post handler");
+		BUG();
+	}
+
+	/* 
+	 * Here vdev_dispatch_io looks if the current address belongs
+	 * to the emulation layer; If it does it returns 0
+	 */
+	val = 0;
+	rc = vdev_dispatch_io(my_trace,&val);
+
+	switch (my_reason->type) {
+	case REG_READ:
+		/* 
+		 * set_ins_reg_val walk the instruction sets and identify the register
+		 * that contain the readed value. For the emulation case we replace that
+		 * value with the emulated one returned from vdev_dispatch_io.
+		 * 	show_registers(regs);
+		 * 	The trace decoding is performed after to maintain consistency
+		 */
+		if(rc==0)
+			set_ins_reg_val(my_reason->ip, regs, val);
+
+/* not needed
+		my_trace->value = get_ins_reg_val(my_reason->ip, regs);*/
+		break;
+	default:
+		break;
+	}
+
+	/* Here we callback into vdev with mytrace information */
+	put_cpu_var(vdev_cpu_trace);
+	put_cpu_var(vdev_pf_reason);
+}
+
+static void ioremap_trace_core(resource_size_t offset, unsigned long size,
+							void __iomem *addr)
+{
+	static atomic_t next_id;
+	struct remap_trace *trace = kmalloc(sizeof(*trace), GFP_KERNEL);
+	/* These are page-unaligned. */
+	struct mmiotrace_map map = {
+		.phys = offset,
+		.virt = (unsigned long)addr,
+		.len = size,
+		.opcode = MMIO_PROBE
+	};
+
+	if (!trace) {
+		pr_err(NAME "kmalloc failed in ioremap\n");
+		return;
+	}
+
+	*trace = (struct remap_trace) {
+		.probe = {
+			.addr = (unsigned long)addr,
+			.len = size,
+			.pre_handler = pre,
+			.post_handler = post,
+			.private = trace
+		},
+		.phys = offset,
+		.id = atomic_inc_return(&next_id)
+	};
+	map.map_id = trace->id;
+
+	spin_lock_irq(&trace_lock);
+	if (!is_enabled()) {
+		kfree(trace);
+		goto not_enabled;
+	}
+
+	list_add_tail(&trace->list, &trace_list);
+	register_kmmio_probe(&trace->probe);
+
+not_enabled:
+	spin_unlock_irq(&trace_lock);
+}
+
+static void iounmap_trace_core(volatile void __iomem *addr)
+{
+	struct mmiotrace_map map = {
+		.phys = 0,
+		.virt = (unsigned long)addr,
+		.len = 0,
+		.opcode = MMIO_UNPROBE
+	};
+	struct remap_trace *trace;
+	struct remap_trace *tmp;
+	struct remap_trace *found_trace = NULL;
+
+	pr_debug(NAME "Unmapping %p.\n", addr);
+
+	spin_lock_irq(&trace_lock);
+	if (!is_enabled())
+		goto not_enabled;
+
+	list_for_each_entry_safe(trace, tmp, &trace_list, list) {
+		if ((unsigned long)addr == trace->probe.addr) {
+			unregister_kmmio_probe(&trace->probe);
+			list_del(&trace->list);
+			found_trace = trace;
+			break;
+		}
+	}
+	map.map_id = (found_trace) ? found_trace->id : -1;
+
+not_enabled:
+	spin_unlock_irq(&trace_lock);
+	if (found_trace) {
+		synchronize_rcu(); /* unregister_kmmio_probe() requirement */
+		kfree(found_trace);
+	}
+}
+
+static void clear_trace_list(void)
+{
+	struct remap_trace *trace;
+	struct remap_trace *tmp;
+
+	/*
+	 * No locking required, because the caller ensures we are in a
+	 * critical section via mutex, and is_enabled() is false,
+	 * i.e. nothing can traverse or modify this list.
+	 * Caller also ensures is_enabled() cannot change.
+	 */
+	list_for_each_entry(trace, &trace_list, list) {
+		pr_notice(NAME "purging non-iounmapped "
+					"trace @0x%08lx, size 0x%lx.\n",
+					trace->probe.addr, trace->probe.len);
+		unregister_kmmio_probe(&trace->probe);
+	}
+	synchronize_rcu(); /* unregister_kmmio_probe() requirement */
+
+	list_for_each_entry_safe(trace, tmp, &trace_list, list) {
+		list_del(&trace->list);
+		kfree(trace);
+	}
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+static cpumask_var_t downed_cpus;
+
+static void enter_uniprocessor(void)
+{
+	int cpu;
+	int err;
+
+	if (downed_cpus == NULL &&
+	    !alloc_cpumask_var(&downed_cpus, GFP_KERNEL)) {
+		pr_notice(NAME "Failed to allocate mask\n");
+		goto out;
+	}
+
+	get_online_cpus();
+	cpumask_copy(downed_cpus, cpu_online_mask);
+	cpumask_clear_cpu(cpumask_first(cpu_online_mask), downed_cpus);
+	if (num_online_cpus() > 1)
+		pr_notice(NAME "Disabling non-boot CPUs...\n");
+	put_online_cpus();
+
+	for_each_cpu(cpu, downed_cpus) {
+		err = cpu_down(cpu);
+		if (!err)
+			pr_info(NAME "CPU%d is down.\n", cpu);
+		else
+			pr_err(NAME "Error taking CPU%d down: %d\n", cpu, err);
+	}
+out:
+	if (num_online_cpus() > 1)
+		pr_warning(NAME "multiple CPUs still online, "
+						"may miss events.\n");
+}
+
+/* __ref because leave_uniprocessor calls cpu_up which is __cpuinit,
+   but this whole function is ifdefed CONFIG_HOTPLUG_CPU */
+static void __ref leave_uniprocessor(void)
+{
+	int cpu;
+	int err;
+
+	if (downed_cpus == NULL || cpumask_weight(downed_cpus) == 0)
+		return;
+	pr_notice(NAME "Re-enabling CPUs...\n");
+	for_each_cpu(cpu, downed_cpus) {
+		err = cpu_up(cpu);
+		if (!err)
+			pr_info(NAME "enabled CPU%d.\n", cpu);
+		else
+			pr_err(NAME "cannot re-enable CPU%d: %d\n", cpu, err);
+	}
+}
+
+#else /* !CONFIG_HOTPLUG_CPU */
+static void enter_uniprocessor(void)
+{
+	if (num_online_cpus() > 1)
+		pr_warning(NAME "multiple CPUs are online, may miss events. "
+			"Suggest booting with maxcpus=1 kernel argument.\n");
+}
+
+static void leave_uniprocessor(void)
+{
+}
+#endif
+
+void vdev_ioremap(resource_size_t offset, unsigned long size,
+	void __iomem *addr)
+{
+	if (!is_enabled()) /* recheck and proper locking in *_core() */
+		return;
+
+	/*
+	 * Here we check FIRST is the offset / size fall into an emulated 
+	 * device region ONLY then we register the emulation back-end
+	 */
+	ioremap_trace_core(offset, size, addr);
+
+	pr_debug("user_mmiotrace_ioremap_*(0x%llx, 0x%lx) = %p\n",
+			(unsigned long long)offset, size, addr);
+}
+
+void vdev_iounmap(volatile void __iomem *addr)
+{
+	if (!is_enabled()) /* recheck and proper locking in *_core() */
+		return;
+	
+	iounmap_trace_core(addr);
+
+	pr_debug("user_mmiotrace_iounmap_%p\n",addr);
+}
+
+void vdev_enable_mmiotrace(void)
+{
+	if (is_enabled())
+		goto out;
+	
+	kmmio_init();
+	enter_uniprocessor();
+	pr_info(NAME "enabled.\n");
+out:
+	atomic_inc(&mmiotrace_enabled);
+}
+
+void vdev_disable_mmiotrace(void)
+{
+	if (atomic_dec_and_test(&mmiotrace_enabled)){
+		BUG_ON(is_enabled());
+		clear_trace_list(); /* guarantees: no more kmmio callbacks */
+		leave_uniprocessor();
+		kmmio_cleanup();
+		pr_info(NAME "disabled.\n");
+	}
+}
+
+
+
+static struct vdev_io *vdev_search(struct mmiotrace_rw *mmio, int *res, resource_size_t *offset)
+{
+	int x;
+	struct vdev_io *io;
+	struct vdev_resource *vdev_resource;
+	resource_size_t start;
+	resource_size_t end;
+
+	spin_lock(&vdev_lock);
+	list_for_each_entry(io, &vdev_list, list){
+		for(x=0;x<PCI_NUM_RESOURCES;x++){
+			vdev_resource = &io->vdev_resource[x];
+			start = vdev_resource->resource.start;
+			end = vdev_resource->resource.end;
+		//	printk("MMIO %lx %lx %lx\n",(unsigned long)mmio->phys, start,end);
+			if ( (mmio->phys >= start) && (mmio->phys <= end) ){
+				spin_unlock(&vdev_lock);
+		//		printk("MMIO found %lx\n",(unsigned long)mmio->phys);
+				*offset = mmio->phys - start;
+				*res = x;
+				return io;
+			}
+		}
+	}
+	spin_unlock(&vdev_lock);
+	return NULL;
+}
+
+/*
+ * This is the call back to the emulation back-end;
+ * This is either coming from the remap_pfn_rage PTE fault
+ * on hostOS OR
+ * from KVM vcpu_mmio rd/wr
+ * 
+ * the vcpu_mmio is driver by the tdp_pagefault() and works
+ * only for emulated device registered with cpu_register_io_memory
+ * Memory is normally registered with qemu_ram_alloc_from_ptr and doesn't
+ * trap on each access.
+ *
+ * OPTION;
+ * For PT vdev device in qemu we set it up as cpu_register_io_memory; We trap
+ * in vcpu_mmio and send to the emulation layer. This would utilize the 
+ * page_fault/kmmio mechanism like when on the host.
+ * Can also be interceted in KVM directly
+ *
+ * KVM kvm_io_bus_write are matching against guest physical
+ * addr because they know where the mapping is going to be located
+ * in guest physical ADDR; equivalent would be to map 
+ * mmap ( hint = my base addr; )...
+ *
+ * KVM iobus require the kvm context!
+ *
+ * !!!
+ * With qemu we can configure the io for slow_map i.e. trap in qemu and qemu
+ * does the access; This is EXACTLY what we need here and there is only
+ * one entry point into the emulation backend
+ */
+int vdev_dispatch_io(struct mmiotrace_rw *mmio, unsigned long *val)
+{
+	int res;
+	unsigned long value;
+	resource_size_t offset;
+	struct vdev_io *io;
+
+	io = vdev_search(mmio, &res, &offset);
+	if(!io)
+		return -1;
+
+	if(mmio->opcode == MMIO_READ){
+		switch(mmio->width){
+			case 1:
+				if(io->readb){
+					value = io->readb(&io->vdev_resource[res],offset);
+					*val = value;
+					return 0;
+				}
+				return -1;
+			case 2:
+				if(io->readw){
+					value = io->readw(&io->vdev_resource[res],offset);
+					*val = value;
+					return 0;
+				}
+				return -1;
+			case 4:
+				if(io->readl){
+					value = io->readl(&io->vdev_resource[res],offset);
+					*val = value;
+					return 0;
+				}
+				return -1;
+			case 8:
+				if(io->readd){
+					value = io->readd(&io->vdev_resource[res],offset);
+					*val = value;
+					return 0;
+				}
+				return -1;
+			default:
+				printk("Invalid io size %d\n",mmio->width);
+				return -1;
+		}
+	}
+
+	if(mmio->opcode == MMIO_WRITE){
+		switch(mmio->width){
+			case 1:
+				if(io->writeb){
+					io->writeb(&io->vdev_resource[res],offset, mmio->value);
+					return 0;
+				}
+				return -1;
+			case 2:
+				if(io->writew){
+					io->writew(&io->vdev_resource[res],offset, mmio->value);
+					return 0;
+				}
+				return -1;
+			case 4:
+				if(io->writel){
+					io->writel(&io->vdev_resource[res],offset, mmio->value);
+					return 0;
+				}
+				return -1;
+			case 8:
+				if(io->writed){
+					io->writed(&io->vdev_resource[res],offset, mmio->value);
+					return 0;
+				}
+				return -1;
+			default:
+				printk("Invalid io size %d\n",mmio->width);
+				return -1;
+		}
+	}
+
+	return -1;
+}
+EXPORT_SYMBOL(vdev_dispatch_io);
+
+/*
+ * Virtual device / SW SRIOV register themself here
+ */
+int vdev_register_device(struct vdev_io *vdev)
+{
+	spin_lock(&vdev_lock);
+	list_add(&vdev->list, &vdev_list);
+	//TODO check if it already exist and so on...
+	spin_unlock(&vdev_lock);
+	vdev_enable_mmiotrace();
+	return 0;
+}
+EXPORT_SYMBOL(vdev_register_device);
+
+/*
+ * Virtual device / SW SRIOV un-register themself here
+ */
+int vdev_unregister_device(struct vdev_io *vdev)
+{
+	int found=0;
+	struct vdev_io *p;
+
+	spin_lock(&vdev_lock);
+	list_for_each_entry(p, &vdev_list, list){
+		if(vdev == p){
+			list_del(&p->list);
+			found=1;
+			break;
+		}
+	}
+	spin_unlock(&vdev_lock);
+	if(found)
+		vdev_disable_mmiotrace();
+		
+	return 0;
+}
+EXPORT_SYMBOL(vdev_unregister_device);
+
+/*
+ * Here we arm the remap_pfn_range KMMIO tracing subsystem only if it deal 
+ * with a fully registered virtual device.
+ *
+ * This path is also called from the mmiotrace_ioremap / kernel ioremap path
+ *
+ */
+void vdev_register_mapping(resource_size_t offset, unsigned long size,
+	void __iomem *addr)
+{
+	vdev_ioremap(offset, size, addr);
+}
+EXPORT_SYMBOL(vdev_register_mapping);
+
+void vdev_unregister_mapping(volatile void __iomem *addr)
+{
+	vdev_iounmap(addr);
+}
+EXPORT_SYMBOL(vdev_unregister_mapping);
+
+
+
+
diff --git a/include/linux/vdevice.h b/include/linux/vdevice.h
new file mode 100644
index 0000000..1d18bb6
--- /dev/null
+++ b/include/linux/vdevice.h
@@ -0,0 +1,65 @@
+/*
+ * vdevice - Virtual Device Framework
+ *
+ * Copyright (C) 2010 Cisco Systems
+ * Author: Etienne Martineau <etmartin@cisco.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.
+ * Copyright (C) 2010 Cisco Systems
+ *
+ */
+#ifndef __V_DEVICE_H_
+#define __V_DEVICE_H_
+
+#include <linux/pci.h>
+
+#define MAX_RESOURCE 6 /* Internally kernel defines PCI_NUM_RESOURCES */
+#define MAX_CFG_SIZE 4096
+
+enum vdevice_type{
+	NEW_FUNCTION,
+	NEW_DEVICE
+};
+
+/* This structure is shared between kernel and user */
+struct vdev{
+#ifdef __KERNEL__
+	struct list_head list;
+	struct pci_dev *pdev; // Root device
+	struct pci_dev *vdev; // Virtual device
+	struct vdev_io *vdev_io; //Emulation backend
+#endif
+
+	enum vdevice_type type;
+
+	int devfn; /* for new_device */
+	int fcnnr; /* for new_function */ 
+
+	uint8_t B;
+	uint8_t D;
+	uint8_t F;
+	uint8_t VD;
+
+	/* emulated pci topology off the downstream port */
+	uint8_t aseg;
+	uint8_t abus;
+	uint8_t adevfn;
+
+	/* bar config */
+	unsigned int bar[6+1+4]; //4 word for padding
+
+	/* pci config space */
+	uint8_t config[MAX_CFG_SIZE];
+};
+
+// TODO clean up this overlay
+#define USER_OFFSET (sizeof(struct list_head) + (sizeof(struct pci_dev*) * 2) + sizeof(struct vdev_io*))
+
+static inline void vdevice_setbar(struct vdev* dev, unsigned int bar,int size, int type)
+{
+	type=type;
+	dev->bar[(bar>>2)-1]=size;
+}
+
+#endif
+
-- 
1.7.0.4

