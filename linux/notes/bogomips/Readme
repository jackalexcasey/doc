#
# get lpj per-cpu
#
sudo insmod bogomips.ko

# 
# Place the executing on the apropriate CPU
#
bash
taskset -pc 'cpu' 'pid of bash'
chrt -p -r 'prio' 'pid'

# 
# From dmesg, kernel reports lpj.
# Calibrating delay loop (skipped), value calculated using timer frequency.. 4788.65 BogoMIPS (lpj=23943270)

# The lpj value can be either 'calibrated' -> using a binary convergence algorithm or derived 
# against a predefined time base. In any case the lpj is the number of TSC cycle during 
# a given interval ( 1 jiffie ) which is set from a walltime counter.
#
# Example:
# The CPU frequency cycle is 2393.711 MHz, lpj is 23939924
#  ==> 23939924 bus cycle during 1 jiffie where 1 bus cycle = 1/2393.711 MHz
#  ==> 10msec per jiffie
#  ==> CONFIG_HZ_100=y
#
# Using the bogomips.ko with no argument, the lpj per-cpu table is provided which
# shows the jitter across the core:
#
# [110494.851126] PER CPU lpj info
# [110494.851128] CPU 0 : lpj 23937110
# [110494.851130] CPU 1 : lpj 23939898
# [110494.851131] CPU 2 : lpj 23939924
# [110494.851132] CPU 3 : lpj 23939942
#
# The number of 'SW loops' that can be done during a 1 jiffie depends on the time it
# takes to execute 1 loop. Give the 'SW loops' is always takes 2 bus cycle per loop
# 
# Note:
# - If we use the 'SW loop' and count to 23939924/2 it should take 1 jiffie exactly ( or 23939924 bus cycle )
#
#  ./bogomips -l100 -j11969962 -c1
#   >>> 0,23946328; VS 23939924 =~ 6404 cycle differences >> 2.6 usec
#   >>> 0,23946120; VS 23939924 =~ 6196 cycle differences
#
#   # Correcting for this offset in the program 6000 /2 
#   0,23940732; VS 23939924 =~ 808 >> 330 nsec
#   0,23940684; VS 23939924 =~ 760
#
# Example of a synthetic load:
#  Let's assume we want to take exactly 1% out of 1 CPU; We can do:
#  Count to 23939924/2 ( which is 10 msec OR 1 jiffie ) and sleep 990 msec
#
#  1%
#  ./bogomips -l1 -j11969962 -c1 -L100 -p990000
#
#  4%
#  ./bogomips -l1 -j11969962 -c1,2,3,4 -L100 -p990000
#
#  50%
#  ./bogomips -l1 -j598498100 -c1 -L100 -p500000
#
#  40%
#  ./bogomips -l1 -j119699620 -c1,2,3,4 -L100 -p900000
#
#  EX scale results:
#  
#  1% load/cpu at duty cycle 10 msec / 990 msec
#  ./bogomips -l1000 -j11969962 -c0,1,2,3 -L100 -p990000 &> /tmp/p1 &
#
#  1% load/cpu at duty cycle 1 msec / 99 msec
#  ./bogomips -l1000 -j1196996 -c0,1,2,3 -L100 -p99000 &> /tmp/p1 &

#  1% load/cpu at duty cycle 100 usec / 9900 usec
#  ./bogomips -l1000 -j119699 -c0,1,2,3 -L100 -p9900 &> /tmp/p1 &

#  1% load/cpu at duty cycle 10 usec / 990 usec
#  ./bogomips -l1000 -j11969 -c0,1,2,3 -L100 -p990 &> /tmp/p1 &
#

sudo rmmod bogomips
sudo dmesg -c >/dev/null
sudo insmod bogomips.ko l=1000 j=100000
sudo chown etmartin /sys/kernel/debug/spinloop
sudo chgrp etmartin /sys/kernel/debug/spinloop
sudo chmod ug+rwx /sys/kernel/debug/spinloop

./bogomips -l 1000 -j 100000 -c1 &> u.csv
./bogomips -l 1000 -j 100000 -c1 -k &> k.csv

# NOTES:
# Current execution is done on kworker thread ... -< because of the insmod thing
# http://www.thinkwiki.org/wiki/How_to_make_use_of_Dynamic_Frequency_Scaling

#
# Disable hyper -threading and dynamic PWR mgmt
# Turn off the watchdog thread.
#
cd /proc/sys/kernel
echo 0 >watchdog

