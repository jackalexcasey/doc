#
# get lpj per-cpu
#
sudo insmod bogomips.ko

# 
# Place the executing on the apropriate CPU
#
bash
taskset -pc 'cpu' 'pid of bash'
chrt -p -r 'prio' 'pid'

# 
# From the dmesg per cpu lpj table run user space and kernel space
#
# [ 8908.370689] PER CPU lpj info
# [ 8908.370696] CPU 0 : lpj 6383772
# [ 8908.370700] CPU 1 : lpj 6383358
# [ 8908.370703] CPU 2 : lpj 6383361
# [ 8908.370706] CPU 3 : lpj 6383353
#
# lpj information gives us the amount of TSC cycle in a jiffie period
# It doesn't not give the auto-calibrate loop number value.
#


sudo rmmod bogomips
sudo dmesg -c >/dev/null
sudo insmod bogomips.ko l=1000 j=100000
sudo chown etmartin /sys/kernel/debug/spinloop
sudo chgrp etmartin /sys/kernel/debug/spinloop
sudo chmod ug+rwx /sys/kernel/debug/spinloop

./bogomips -l 1000 -j 100000 -c1 &> u.csv
./bogomips -l 1000 -j 100000 -c1 -k &> k.csv

# NOTES:
# Current execution is done on kworker thread ... -< because of the insmod thing
# http://www.thinkwiki.org/wiki/How_to_make_use_of_Dynamic_Frequency_Scaling

#
# Disable hyper -threading and dynamic PWR mgmt
# Turn off the watchdog thread.
#
cd /proc/sys/kernel
echo 0 >watchdog



# 
# Limitation
#

# This is the loop that does the measurement.
	for(x=0;x<loop_nr;x++){
		t1 = get_cycles();
		__ldelay(lpj);
		t2 = get_cycles();
		pcpu->delta[x] = t2-t1; 
	}

# At assembly level this translate into a series of opcodes
	for(x=0;x<loop_nr;x++){		// A,B,C,D
		t1 = get_cycles();		// E,F
		__ldelay(lpj);			// G,H
		t2 = get_cycles();		// I,J
		pcpu->delta[x] = t2-t1; // K
	}							// L,M,N
# t1 is obtain when F complete execution 
# t2 is obtain when J complete execution
# So this test measure if we are preempted during the [G,H,I,J] period
# A,B,C,D,E,F [G,H,I,J] K,L,M,N
# The period [A,B,C,D,E,F] OR [K,L,M,N] may take arbitrary long without beeing noticed.



# Another approach to the problem would be to do the following:
	for(x=0;x<loop_nr;x++){				
		t1 = get_cycles();				
		t3 = t1 - t2;					
		__ldelay(lpj);					
		t2 = get_cycles();				
		if(!x)
			pcpu->delta[x] = t1; // Mark the start of the test
		else
			pcpu->delta[x] = t2-t1 + t3; // Charge t3 on the next run
	}									

If we run the above test in a loop and in the loop we find out how much
off we are from t2-t1 + t3;
the calibrated value should be the one without the cache effect.
Then we can mark a % value from the optimal case.


# t1 is obtain when F complete execution
# t2 is obtain when N complete execution
# A,B,C,D,E,F [H,I,J,K,L,M,N] O,P,Q,R,S

