# 
# Limitation
#

# This is the loop that does the measurement.
	for(x=0;x<loop_nr;x++){
		t1 = get_cycles();
		__ldelay(lpj);
		t2 = get_cycles();
		pcpu->delta[x] = t2-t1; 
	}

# At assembly level this translate into a series of opcodes
	for(x=0;x<loop_nr;x++){		// A,B,C,D
		t1 = get_cycles();		// E,F
		__ldelay(lpj);			// G,H
		t2 = get_cycles();		// I,J
		pcpu->delta[x] = t2-t1; // K
	}							// L,M,N
# t1 is obtain when F complete execution 
# t2 is obtain when J complete execution
# So this test measure if we are preempted during the [G,H,I,J] period
# A,B,C,D,E,F [G,H,I,J] K,L,M,N
# The period [A,B,C,D,E,F] OR [K,L,M,N] may take arbitrary long without beeing noticed.



# Another approach to the problem would be to do the following:
	for(x=0;x<loop_nr;x++){				
		t1 = get_cycles();				
		t3 = t1 - t2;					
		__ldelay(lpj);					
		t2 = get_cycles();				
		if(!x)
			pcpu->delta[x] = t1; // Mark the start of the test
		else
			pcpu->delta[x] = t2-t1 + t3; // Charge t3 on the next run
	}									

If we run the above test in a loop and in the loop we find out how much
off we are from t2-t1 + t3;
the calibrated value should be the one without the cache effect.
Then we can mark a % value from the optimal case.


# t1 is obtain when F complete execution
# t2 is obtain when N complete execution
# A,B,C,D,E,F [H,I,J,K,L,M,N] O,P,Q,R,S

c
